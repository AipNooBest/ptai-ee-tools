package com.ptsecurity.appsec.ai.ee.utils.ci.integration.jenkins;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.ptsecurity.appsec.ai.ee.utils.ci.integration.jenkins.exceptions.JenkinsClientException;
import com.ptsecurity.appsec.ai.ee.utils.ci.integration.jenkins.exceptions.JenkinsServerException;
import com.ptsecurity.appsec.ai.ee.utils.ci.integration.jenkins.utils.ApiClient;
import com.ptsecurity.appsec.ai.ee.utils.ci.integration.jenkins.utils.JenkinsApiClientWrapper;
import com.ptsecurity.appsec.ai.ee.utils.ci.integration.ptaiserver.domain.PtaiResultStatus;
import com.ptsecurity.appsec.ai.ee.utils.ci.jenkins.server.ApiException;
import com.ptsecurity.appsec.ai.ee.utils.ci.jenkins.server.ApiResponse;
import com.ptsecurity.appsec.ai.ee.utils.ci.jenkins.server.rest.Artifact;
import com.ptsecurity.appsec.ai.ee.utils.ci.jenkins.server.rest.DefaultCrumbIssuer;
import com.ptsecurity.appsec.ai.ee.utils.ci.jenkins.server.rest.FreeStyleBuild;
import com.ptsecurity.appsec.ai.ee.utils.ci.jenkins.server.rest.FreeStyleProject;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import org.apache.commons.lang3.StringUtils;
import org.apache.http.HttpStatus;

import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Pattern;

public class SastJob extends Client {
    public static final String PROJECT_NAME = "PTAI_PROJECT_NAME";
    public static final String NODE_NAME = "PTAI_NODE_NAME";
    public static final String SETTINGS_JSON = "PTAI_SETTINGS_JSON";
    public static final String POLICY_JSON = "PTAI_POLICY_JSON";

    @Getter
    @Setter
    protected String jobName;
    @Getter
    @Setter
    protected String projectName;
    @Getter
    @Setter
    protected String nodeName;
    @Getter
    @Setter
    protected String settingsJson;
    @Getter
    @Setter
    protected String policyJson;

    protected com.ptsecurity.appsec.ai.ee.utils.ci.jenkins.server.ApiResponse<DefaultCrumbIssuer> crumb;

    public String testSastJob() throws JenkinsServerException {
        String jobName = ApiClient.convertJobName(this.jobName);
        try {
            FreeStyleProject prj = this.jenkinsApi.getJob(jobName);
            return prj.getDisplayName();
        } catch (ApiException e) {
            log(e);
            throw new JenkinsServerException(e.getMessage(), e);
        }
    }

    public PtaiResultStatus execute(String reportFolderName) throws JenkinsClientException {
        // Autogenerated Jenkins API does not support folders so we need to
        // hack job name
        if (StringUtils.isEmpty(this.jobName))
            throw new JenkinsClientException("Job name is not set");
        final String jobName = ApiClient.convertJobName(this.jobName);
        JenkinsApiClientWrapper apiClient = new JenkinsApiClientWrapper(this, 5, 5000);
        FreeStyleBuild sastBuild = null;
        Integer queueId = null;

        try {

            FreeStyleProject prj = apiClient.callApi(() -> this.jenkinsApi.getJob(jobName));
            Integer buildId = prj.getNextBuildNumber();
            JenkinsJsonParameter params = new JenkinsJsonParameter();
            params.add("PTAI_PROJECT_NAME", Optional.ofNullable(this.projectName).orElse(""));
            params.add("PTAI_NODE_NAME", Optional.ofNullable(this.nodeName).orElse(""));
            params.add("PTAI_SETTINGS_JSON", Optional.ofNullable(this.settingsJson).orElse(""));
            params.add("PTAI_POLICY_JSON", Optional.ofNullable(this.policyJson).orElse(""));
            ObjectMapper objectMapper = new ObjectMapper();
            // Start SAST job
            String paramsJson = objectMapper.writeValueAsString(params);
            ApiResponse<Void> buildQueueInfo = apiClient.callApi(() -> jenkinsApi.postJobBuildWithHttpInfo(jobName, paramsJson, null, apiClient.crumb()));
            queueId = Client.getQueueId(buildQueueInfo);

            do {
                try {
                    // There may be a situation where build is not started yet, so we'll get an "not found" exception
                    buildId = getBuildId(jobName, queueId);
                    if (null == buildId) {
                        this.log("Wait 5 seconds for %s job to start\r\n", this.jobName);
                        Thread.sleep(5000);
                        continue;
                    }
                    final String buildIdStr = buildId.toString();
                    sastBuild = apiClient.callApi(() -> jenkinsApi.getJobBuild(jobName, buildIdStr));
                    if (null != sastBuild) {
                        this.log("Job %s started\r\n", this.jobName);
                        break;
                    } else
                        throw new JenkinsClientException("SAST job build is null");
                } catch (JenkinsServerException e) {
                    this.log("%s job start failed, code: %d, message: %s\r\n", this.jobName, e.getCode(), e.getMessage());
                    throw new JenkinsClientException(e.getMessage());
                }
            } while (true);
            final String buildIdStr = buildId.toString();
            // Wait till SAST job is complete
            int start = 0;
            PtaiResultStatus sastJobRes = PtaiResultStatus.UNSTABLE;
            do {
                sastBuild = apiClient.callApi(() -> jenkinsApi.getJobBuild(jobName, buildIdStr));
                if (null == sastBuild) break;
                com.ptsecurity.appsec.ai.ee.utils.ci.jenkins.server.ApiResponse<String> sastJobLog;
                String startStr = String.valueOf(start);
                sastJobLog = apiClient.callApi(() -> jenkinsApi.getJobProgressiveTextWithHttpInfo(jobName, buildIdStr, startStr));
                if (HttpStatus.SC_OK != sastJobLog.getStatusCode()) break;
                // Just to simplify processing of optional headers array
                int pos;
                try {
                    pos = Integer.parseInt(sastJobLog.getHeaders().get("X-Text-Size").get(0));
                } catch (Exception e) {
                    break;
                }
                if (pos != start) {
                    String[] lines = sastJobLog.getData().split("\\r?\\n");
                    for (String line : lines)
                        log("%s\r\n", line);
                    start = pos;
                }
                Thread.sleep(1000);
                if (StringUtils.isEmpty(sastBuild.getResult())) continue;
                try {
                    sastJobRes = PtaiResultStatus.valueOf(sastBuild.getResult());
                    break;
                } catch (Exception e) {
                    log(e);
                }
            } while (true);
            // Save results
            if (PtaiResultStatus.UNSTABLE.equals(sastJobRes)) return sastJobRes;
            sastBuild = apiClient.callApi(() -> jenkinsApi.getJobBuild(jobName, buildIdStr));
            for (Artifact artifact : sastBuild.getArtifacts()) {
                String resultFile = apiClient.callApi(() -> jenkinsApi.getJobBuildArtifact(jobName, buildIdStr, artifact.getRelativePath()));
                saveReport(reportFolderName, artifact.getFileName(), resultFile);
            }
            return sastJobRes;
        } catch (IOException e) {
            log(e);
            throw new JenkinsServerException(e.getMessage(), e);
        } catch (InterruptedException e) {
            log(e);
            if (null != queueId)
                stopJob(jobName, queueId);
            throw new JenkinsClientException(e.getMessage(), e);
        }
    }

    protected void saveReport(String folder, String artifact, String data) throws IOException, InterruptedException {
        Files.write(
                Paths.get(folder + File.separator + artifact),
                data.getBytes(StandardCharsets.UTF_8),
                StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
    }

    public static class JenkinsJsonParameter {
        @AllArgsConstructor
        static class NameValuePair {
            @Getter
            private String name;
            @Getter
            private String value;
        }
        @Getter
        private final List<NameValuePair> parameter = new ArrayList<>();

        @SuppressWarnings("UnusedReturnValue")
        public NameValuePair add(String name, String value) {
            NameValuePair res = new NameValuePair(name, value);
            parameter.add(res);
            return res;
        }
    }
}
